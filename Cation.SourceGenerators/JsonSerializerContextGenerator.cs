using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cation.SourceGenerators;

[Generator]
public class JsonSerializerContextGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is ClassDeclarationSyntax { BaseList: not null },
                transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(cds => cds != null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
        {
            var (compilation, candidates) = source;
            var jsonSerializerContextSymbol =
                compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonSerializerContext");
            if (jsonSerializerContextSymbol == null)
                return;

            foreach (var candidate in candidates)
            {
                var model = compilation.GetSemanticModel(candidate.SyntaxTree);
                var symbol = model.GetDeclaredSymbol(candidate) as INamedTypeSymbol;
                if (symbol == null)
                    continue;
                if (!InheritsFrom(symbol, jsonSerializerContextSymbol))
                    continue;

                var ns = symbol.ContainingNamespace.IsGlobalNamespace ? null : symbol.ContainingNamespace.ToString();
                var className = symbol.Name;
                var sourceText = $@"// <auto-generated/>
#nullable enable
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

{(ns != null ? $"namespace {ns};" : string.Empty)}

partial class {className}
{{
    public static async Task<TValue?> DeserializeAsync<TValue>(
        Stream utf8Json,
        CancellationToken cancellationToken = default)
    {{
        return (TValue?)await JsonSerializer.DeserializeAsync(utf8Json, Default.GetTypeInfo(typeof(TValue))!,
            cancellationToken);
    }}

    public static TValue? Deserialize<TValue>(Stream utf8Json)
    {{
        return (TValue?)JsonSerializer.Deserialize(utf8Json, Default.GetTypeInfo(typeof(TValue))!);
    }}

    public static TValue? Deserialize<TValue>(JsonElement element)
    {{
        return element.Deserialize<TValue>(Default.Options);
    }}
}}
";
                spc.AddSource($"{className}.g.cs", sourceText);
            }
        });
    }

    private static bool InheritsFrom(INamedTypeSymbol symbol, INamedTypeSymbol baseType)
    {
        var current = symbol.BaseType;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
            current = current.BaseType;
        }

        return false;
    }
}
