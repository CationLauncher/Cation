using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cation.SourceGenerators;

[Generator]
public class JsonSerializerContextGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        var compilation = context.Compilation;
        var jsonSerializerContextSymbol =
            compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonSerializerContext");
        if (jsonSerializerContextSymbol == null)
            return;

        foreach (var candidate in receiver.Candidates)
        {
            var model = compilation.GetSemanticModel(candidate.SyntaxTree);
            var symbol = model.GetDeclaredSymbol(candidate) as INamedTypeSymbol;
            if (symbol == null)
                continue;
            if (!InheritsFrom(symbol, jsonSerializerContextSymbol))
                continue;

            var ns = symbol.ContainingNamespace.IsGlobalNamespace ? null : symbol.ContainingNamespace.ToString();
            var className = symbol.Name;
            var source = $@"// <auto-generated/>
#nullable enable
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

{(ns != null ? $"namespace {ns};" : string.Empty)}

partial class {className}
{{
    public static async Task<TValue?> DeserializeAsync<TValue>(
        Stream utf8Json,
        CancellationToken cancellationToken = default)
    {{
        return (TValue?)await JsonSerializer.DeserializeAsync(utf8Json, Default.GetTypeInfo(typeof(TValue))!,
            cancellationToken);
    }}

    public static TValue? Deserialize<TValue>(Stream utf8Json)
    {{
        return (TValue?)JsonSerializer.Deserialize(utf8Json, Default.GetTypeInfo(typeof(TValue))!);
    }}

    public static TValue? Deserialize<TValue>(JsonElement element)
    {{
        return element.Deserialize<TValue>(Default.Options);
    }}
}}
";
            context.AddSource($"{className}.g.cs", source);
        }
    }

    private static bool InheritsFrom(INamedTypeSymbol symbol, INamedTypeSymbol baseType)
    {
        var current = symbol.BaseType;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
            current = current.BaseType;
        }

        return false;
    }

    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> Candidates { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax cds && cds.BaseList != null)
            {
                Candidates.Add(cds);
            }
        }
    }
}
